{"initialInterfaces":["quickApp"],"apiVersion":"1.3","type":"com.fibaro.genericDevice","initialProperties":{"supportedDeviceRoles":["Other"],"useEmbededView":true,"viewLayout":{"$jason":{"body":{"header":{"title":"quickApp_device_52","style":{"height":"500"}},"sections":{"items":[{"type":"vertical","components":[{"visible":true,"style":{"weight":"1.2"},"type":"label","name":"title","text":""},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"options":{},"visible":true,"values":{},"style":{"weight":"1.2"},"type":"select","name":"qaSelect","text":"QA dist","selectionType":"single"},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"visible":true,"style":{"weight":"1.2"},"type":"label","name":"qaAuthor","text":""},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"visible":true,"style":{"weight":"1.2"},"type":"label","name":"qaDescr","text":""},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"options":{},"visible":true,"values":{},"style":{"weight":"1.2"},"type":"select","name":"qaVersion","text":"Version","selectionType":"single"},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"visible":true,"style":{"weight":"1.2"},"type":"label","name":"vaDescr","text":""},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"options":{},"visible":true,"values":{},"style":{"weight":"1.2"},"type":"select","name":"qaUpdate","text":"Update","selectionType":"single"},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"visible":true,"style":{"weight":"1.2"},"type":"label","name":"info","text":""},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"type":"horizontal","components":[{"visible":true,"style":{"weight":"0.33"},"type":"button","name":"b1","text":"Update"},{"visible":true,"style":{"weight":"0.33"},"type":"button","name":"b2","text":"Install"},{"visible":true,"style":{"weight":"0.33"},"type":"button","name":"b3","text":"Refresh"}],"style":{"weight":"1.2"}},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}},{"type":"vertical","components":[{"visible":true,"style":{"weight":"1.2"},"type":"label","name":"log","text":""},{"type":"space","style":{"weight":"0.5"}}],"style":{"weight":"1.2"}}]}},"head":{"title":"quickApp_device_52"}}},"uiView":[{"type":"horizontal","components":[{"visible":true,"style":{"weight":"1.0"},"type":"label","name":"title","text":""}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"text":"QA dist","type":"select","values":{},"style":{"weight":"1.0"},"options":{},"eventBinding":{"onToggled":[{"params":{"args":["onToggled","qaSelect","$event.value"],"actionName":"UIAction"},"type":"deviceAction"}]},"name":"qaSelect","selectionType":"single"}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"style":{"weight":"1.0"},"type":"label","name":"qaAuthor","text":""}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"style":{"weight":"1.0"},"type":"label","name":"qaDescr","text":""}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"text":"Version","type":"select","values":{},"style":{"weight":"1.0"},"options":{},"eventBinding":{"onToggled":[{"params":{"args":["onToggled","qaVersion","$event.value"],"actionName":"UIAction"},"type":"deviceAction"}]},"name":"qaVersion","selectionType":"single"}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"style":{"weight":"1.0"},"type":"label","name":"vaDescr","text":""}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"text":"Update","type":"select","values":{},"style":{"weight":"1.0"},"options":{},"eventBinding":{"onToggled":[{"params":{"args":["onToggled","qaUpdate","$event.value"],"actionName":"UIAction"},"type":"deviceAction"}]},"name":"qaUpdate","selectionType":"single"}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"style":{"weight":"1.0"},"type":"label","name":"info","text":""}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"text":"Update","type":"button","eventBinding":{"onLongPressReleased":[{"params":{"args":["onLongPressReleased","b1"],"actionName":"UIAction"},"type":"deviceAction"}],"onReleased":[{"params":{"args":["onReleased","b1"],"actionName":"UIAction"},"type":"deviceAction"}],"onLongPressDown":[{"params":{"args":["onLongPressDown","b1"],"actionName":"UIAction"},"type":"deviceAction"}]},"style":{"weight":"0.25"},"name":"b1"},{"visible":true,"text":"Install","type":"button","eventBinding":{"onLongPressReleased":[{"params":{"args":["onLongPressReleased","b2"],"actionName":"UIAction"},"type":"deviceAction"}],"onReleased":[{"params":{"args":["onReleased","b2"],"actionName":"UIAction"},"type":"deviceAction"}],"onLongPressDown":[{"params":{"args":["onLongPressDown","b2"],"actionName":"UIAction"},"type":"deviceAction"}]},"style":{"weight":"0.25"},"name":"b2"},{"visible":true,"text":"Refresh","type":"button","eventBinding":{"onLongPressReleased":[{"params":{"args":["onLongPressReleased","b3"],"actionName":"UIAction"},"type":"deviceAction"}],"onReleased":[{"params":{"args":["onReleased","b3"],"actionName":"UIAction"},"type":"deviceAction"}],"onLongPressDown":[{"params":{"args":["onLongPressDown","b3"],"actionName":"UIAction"},"type":"deviceAction"}]},"style":{"weight":"0.25"},"name":"b3"}],"style":{"weight":"1.0"}},{"type":"horizontal","components":[{"visible":true,"style":{"weight":"1.0"},"type":"label","name":"log","text":""}],"style":{"weight":"1.0"}}],"deviceRole":"Other","quickAppVariables":[],"manufacturer":"","uiCallbacks":[{"eventType":"onToggled","callback":"qaSelect","name":"qaSelect"},{"eventType":"onToggled","callback":"qaVersion","name":"qaVersion"},{"eventType":"onToggled","callback":"qaUpdate","name":"qaUpdate"},{"eventType":"onReleased","callback":"update","name":"b1"},{"eventType":"onLongPressDown","callback":"","name":"b1"},{"eventType":"onLongPressReleased","callback":"","name":"b1"},{"eventType":"onReleased","callback":"install","name":"b2"},{"eventType":"onLongPressDown","callback":"","name":"b2"},{"eventType":"onLongPressReleased","callback":"","name":"b2"},{"eventType":"onReleased","callback":"refresh","name":"b3"},{"eventType":"onLongPressDown","callback":"","name":"b3"},{"eventType":"onLongPressReleased","callback":"","name":"b3"}],"buildNumber":1,"model":"","apiVersion":"1.3","typeTemplateInitialized":true,"userDescription":"","quickAppUuid":"","useUiView":false},"name":"FibPatchProxy","files":[{"isOpen":false,"content":"local fmt = string.format\n\nlocal EVENT = fibaro.EVENT or {}\nfibaro.EVENT = EVENT\n\nfunction QuickApp:post(event)\n  if EVENT[event.type] then\n    setTimeout(function() EVENT[event.type](event) end,0)\n  end\nend\n\nfunction table.map(t,f)\n  local r = {}\n  for i,v in ipairs(t) do\n    r[i] = f(v)\n  end\n  return r\nend\n\n----------------- Github -----------------\nlocal function urlencode(str) -- very useful\n  if str then\n    str = str:gsub(\"\\n\", \"\\r\\n\")\n    str = str:gsub(\"([ %-%_%.%~])\", function(c)\n      return (\"%%%02X\"):format(string.byte(c))\n    end)\n    str = str:gsub(\" \", \"%%20\")\n  end\n  return str\t\nend\n\nlocal function trim(s)\n  return s:match(\"(.+)%.fqa$\") or s\nend\n\nfunction QuickApp:getLibraryFile(url,cb)\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status < 204 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\nfunction QuickApp:git_getQA(user,repo,name,tag,cb)\n  local url = urlencode(fmt(\"\/%s\/%s\/%s\/%s\",user,repo,tag,name))\n  url = \"https:\/\/raw.githubusercontent.com\"..url\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status == 200 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\nfunction QuickApp:git_getQAReleases(user,repo,name,cb)\n  name = trim(name)\n  name = name..\".releases\"\n  local url = urlencode(fmt(\"\/%s\/%s\/master\/%s\",user,repo,name))\n  url = \"https:\/\/raw.githubusercontent.com\"..url\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status == 200 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\nfunction QuickApp:git_getQATags(user,repo,cb)\n  local url = fmt(\"https:\/\/api.github.com\/repos\/%s\/%s\/tags\",user,repo)\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status == 200 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\n------------------ Selectable ------------------\nlocal function mkKey(item) return tostring(item):gsub(\"[^%w]\",\"\") end\nSelectable = Selectable\nclass 'Selectable'\nfunction Selectable:__init(qa,id)\n  local fun = nil\n  assert(type(qa)=='userdata',\"First argument must be the QuickApp (self)\")\n  assert(self.text,\"Selectable:text(item) not defined\")\n  assert(self.value,\"Selectable:value(item) not defined\")\n  for _,c in ipairs(qa.properties.uiCallbacks or {}) do\n    if c.name==id then fun = c.callback break end\n  end\n  assert(fun,\"Selectable \"..tostring(id)..\" not found in uiCallbacks\")\n  self.id = id\n  self.qa = qa\n  self.fun = fun\n  self.qa[fun] = function(_,event)\n    if self.map == nil then\n      return fibaro.warning(__TAG,\"Selectable \"..self.id..\" not initialized\")\n    end\n    self.key = tostring(event.values[1])\n    self.item = self.map[self.key]\n    if self.item == nil then\n      return fibaro.warning(__TAG,\"Selecable: Invalid value: \"..self.key)\n    end\n    self._value = self:value(self.item)\n    if self.selected then\n      self:selected(self.item)\n    end\n  end\nend\nfunction Selectable:update(list)\n  local r = {}\n  for _,item in pairs(list) do\n    if self.filter then \n      if self:filter(item) then table.insert(r,item) end\n    else table.insert(r,item) end\n  end\n  if self.sort then\n    local function sort(a,b) return self:sort(a,b) end\n    table.sort(r,sort) \n  end\n  self.list = r\n  self.map = {}\n  local options = {}\n  for _,item in ipairs(self.list) do\n    local value = mkKey(self:value(item))\n    local name = self:text(item)\n    self.map[value] = item\n    table.insert(options,{text=name,type='option',value=value})\n  end\n  self.options = options\n  --Get around bug that don't update the list if empty\n  if next(options) == nil then options={{text=\"\",type=\"option\",value=\"\"}} end\n  self:_updateList(\"options\",options)\n  self:_updateList(\"selectedItem\",\"\")\nend\nfunction Selectable:select(value)\n  value = mkKey(value)\n  if not self.map[value] then \n    return fibaro.warning(__TAG,\"Invalid value: \"..value)\n  end\n  self:_updateList(\"selectedItem\",value)\n  self.qa[self.fun](self.qa,{values={value}})\n  self:selected(self.map[value])\nend\n\nfunction Selectable:_updateList(prop,value)\n  self.qa:updateView(self.id,prop,value)\nend\n\n--[[\nfunction Selectable:selected(value) ...end\nfunction Selectable:value(item) return item.<value> end\nfunction Selectable:text(item) return item.<text> end\nfunction Selectable:sort(a,b) return a.name < b.name end\nSelectable.item\n--]]","isMain":false,"type":"lua","name":"utils"},{"isOpen":false,"content":"QA_DIR = {\n  {user=\"jangabrielsson\",repo=\"fibpatch\",name=\"QA_A.fqa\"},\n  {user=\"jangabrielsson\",repo=\"fibpatch\",name=\"QA B.fqa\"},\n}\n\nQA_LIBRARIES = {\n  \"https:\/\/raw.githubusercontent.com\/jangabrielsson\/hc3emu\/refs\/heads\/main\/jgabsQAs.json\"\n}","isMain":false,"type":"lua","name":"dir"},{"isOpen":false,"content":"_DEVELOP=\"..\/hc3emu\"\nif require and not QuickApp then require('hc3emu') end\n\n--%%name=fibpatch\n--%%type=com.fibaro.genericDevice\n--%%proxy=FibPatchProxy\n--%%save=FibPatch.fqa\n--%%file=utils.lua:utils\n--%%file=dir.lua:dir\n\n--%%u={label='title',text=''}\n--%%u={select='qaSelect', text='QA dist', onToggled='qaSelect', options={}}\n--%%u={label='qaAuthor',text=''}\n--%%u={label='qaDescr',text=''}\n--%%u={select='qaVersion', text='Version', onToggled='qaVersion', options={}}\n--%%u={label='vaDescr',text=''}\n--%%u={select='qaUpdate', text='Update', onToggled='qaUpdate', options={}}\n--%%u={label='info',text=''}\n--%%u={{button='b1', text='Update', onReleased='update'},{button='b2', text='Install', onReleased='install'},{button='b3', text='Refresh', onReleased='refresh'}}\n--%%u={label='log',text=''}\n\nlocal test = fibaro.hc3emu ~= nil\nlocal VERSION = \"0.1.0\"\n\nlocal fmt = string.format\nlocal EVENT = fibaro.EVENT or {}\nfibaro.EVENT = EVENT\nQAs,Versions,Dists = QAs,Versions,Dists\n\nlocal function ERRORF(fmt,...) fibaro.error(__TAG,fmt:format(...)) end\n\nlocal function trim(s)\n  return s:match(\"(.+)%.fqa$\") or s\nend\n\nif test then fibaro.hc3emu.installLocal = true end\n\nlocal QAS = {}\n\nclass \"Dists\"(Selectable)\nfunction Dists:__init(qa) Selectable.__init(self,qa,\"qaSelect\") end\nfunction Dists:text(item) return trim(item.name) end\nfunction Dists:value(item) return item.name end\nfunction Dists:sort(a,b) return a.name < b.name end\nfunction Dists:selected(item)\n  DistUID = item.info.uid\n  self.qa.versions:update(item.info.versions)\n  self.qa.qas:update(QAS)\n  self.qa:updateInfo()\nend\n\nclass \"Versions\"(Selectable)\nfunction Versions:__init(qa) Selectable.__init(self,qa,\"qaVersion\") end\nfunction Versions:text(item) return fmt(\"%s, %s\",item.version,item.description) end\nfunction Versions:value(item) return item.version end\nfunction Versions:sort(a,b) return a.version < b.version end\nfunction Versions:selected(item) self.qa:updateInfo() end\n\nclass \"QAs\"(Selectable)\nfunction QAs:__init(qa) Selectable.__init(self,qa,\"qaUpdate\") end\nfunction QAs:text(item) return fmt(\"%s: %s\",item.id,item.name) end\nfunction QAs:value(item) return item.id end\nfunction QAs:sort(a,b) return a.name < b.name end\nfunction QAs:filter(item) return item.properties.quickAppUuid == DistUID end\nfunction QAs:selected(item) self.qa:updateInfo() end\n\nfunction QuickApp:onInit()\n  self:debug(self.name,self.id)\n  self:updateView(\"title\",\"text\",fmt(\"FibPatch v%s\",VERSION))\n  if test then \n    -- fibaro.hc3emu.loadQA(\"test\/QA_A.lua\")\n    -- fibaro.hc3emu.loadQA(\"test\/QA_B.lua\")\n  end\n  \n  self.dists = Dists(self)\n  self.versions = Versions(self)\n  self.qas = QAs(self)\n  \n  self:updateDistInfo()\n  self:updateQAlist()\n  \n  if test then \n    -- self:testQA(\"install\",\"QA_A.fqa\",\"1.0\",nil,2000)\n    self:testQA(\"install\",\"QA_A.fqa\",\"1.0\",nil,2000)\n    \n    self:testQA(\"update\",\"QA_A.fqa\",\"1.1\",5002,6000)\n  end\nend\n\nfunction QuickApp:testQA(cmd,name,version,id,time) -- for testing in emulator\n  time = time or 4000\n  setTimeout(function() \n    self.dists:select(name)\n    self.versions:select(version)\n    if cmd == \"update\" then \n      self.qas:select(id)\n      self:update()\n    elseif cmd == \"install\" then self:install() end\n  end,time)\nend\n\nlocal dir = {}\nlocal function addDist(dist)\n  local stat,res = pcall(function()\n    local key = dist.user..dist.repo..dist.name\n    dir[key] = dist\n  end)\n  local stat2,res2 = pcall(json.encode,dist)\n  res = stat2 and res2 or res\n  if not stat then ERRORF(\"Error adding dist %s\",tostring(res)) end\nend\n\nfunction QuickApp:updateQADir()\n  local n = 0\n  for _,_ in pairs(dir) do n = n+1 end\n  for k,qa in pairs(dir) do \n    local key,user,repo,name = k,qa.user,qa.repo,qa.name\n    self:git_getQAReleases(user,repo,name,function(ok,data)\n      n = n-1\n      if ok then \n        dir[key].info = json.decode(data)\n        self:log(\"Updated %s.%s.%s\",user,repo,name)\n      else self:error(fmt(\"fetching repo %s:%s:%s\", user, repo, name)) end\n      if n == 0 then self.dists:update(dir) end  -- updated to call dists\n    end)\n  end\nend\n\nfunction QuickApp:updateDistInfo()\n  dir = {}\n  for _,dist in ipairs(QA_DIR or {}) do addDist(dist) end\n  local n = #QA_LIBRARIES\n  if n == 0 then return self:updateQADir() end\n  for _,url in ipairs(QA_LIBRARIES or {}) do\n    self:getLibraryFile(url,function(ok,lib)\n      n = n-1\n      if ok then\n        ok,lib = pcall(json.decode,lib)\n        if ok then for _,dist in ipairs(lib) do addDist(dist) end end\n      else self:error(fmt(\"fetching library %s\",url)) end\n      if n == 0 then self:updateQADir() end\n    end)\n  end\nend\n\nlocal qas = {}\nfunction QuickApp:updateQAlist()\n  local res = api.get(\"\/devices?interface=quickApp\") or {}\n  qas = {}\n  for _,d in ipairs(res) do\n    if \n    (d.parentId==nil or d.parentId==0) and\n    (d.encrypted == nil or d.encrypted == false)\n    then\n      table.insert(qas,d)\n    end\n  end\n  QAS = qas\n  self.qas:update(qas)\nend\n\nfunction QuickApp:updateInfo()\n  if self.dists.item then\n    self:updateView(\"qaAuthor\",\"text\",self.dists.item.info.author or \"\")\n    self:updateView(\"qaDescr\",\"text\",self.dists.item.info.description or \"\")\n  else\n    self:updateView(\"qaAuthor\",\"text\",\"\")\n    self:updateView(\"qaDescr\",\"text\",\"\")\n  end\n  if self.versions.item then\n    self:updateView(\"vaDescr\",\"text\",self.versions.item.description or \"\")\n  else\n    self:updateView(\"vaDescr\",\"text\",\"\")\n  end\n  local a = self.dists.item and self.dists.item.name or \"N\/A\"\n  local b = self.versions.item and self.versions.item.version or \"N\/A\"\n  local c = self.qas.item and self.qas.item.name or \"N\/A\"\n  local str = fmt(\"QA:%s\\nVersion:%s\\nUpdate:%s\",a,b,c)\n  local updb = self.dists.item and self.versions.item and self.qas.item and true or false\n  self:updateView(\"b1\",\"visible\",updb)\n  self:updateView(\"info\",\"text\",str)\nend\n\nfunction QuickApp:getQA(cb)\n  if not(self.dists.item and self.versions.item) then\n    return self:error(\"Please select dist, version to install\")\n  end\n  local dist = self.dists.item\n  local version = self.versions.item\n  local tag = version.tag\n  if not tag then \n    return self:error(fmt(\"Version %s not found\",version.version))\n  end\n  self:git_getQA(dist.user,dist.repo,dist.name,tag,function(ok,res)\n    if ok then ok,res = pcall(json.decode,res) end\n    cb(ok,res)\n  end)\nend\n\nfunction QuickApp:update()\n  self:log(\"Update\")\n  if not self.qas.item then\n    return self:logErr(\"Please select QA to update\")\n  end\n  self:getQA(function(ok,res)\n    if not ok then return self:logErr(res) end\n    local eid = self.qas.item.id\n    local version = self.versions.item\n    \n    local function exclude(name)\n      for _,p in ipairs(version.exclude or {}) do\n        local pp = p:match(\"^p:(.*)$\")\n        if pp then return name:match(pp) else return name == p end\n      end \n    end\n    \n    local function equalContent(f)\n      local res,code = api.get(fmt(\"\/quickApp\/%s\/files\/%s\",eid,f.name))\n      if code > 202 then return false end\n      return res.content == f.content\n    end\n    \n    local fqa = res\n    \n    local nprops = fqa.initialProperties\n    local nifs = fqa.initialInterfaces -- do this in QA...\n    \n    -- update files\n    local efile = api.get(fmt(\"\/quickApp\/%s\/files\",eid))\n    local nfile = fqa.files\n    local emap,nmap = {},{}\n    local newFiles = {}\n    local existingFiles = {}\n    local deletedFiles = {}\n    \n    for _,f in ipairs(nfile) do nmap[f.name] = f end\n    for _,f in ipairs(efile) do emap[f.name] = f end\n    for _,f in ipairs(nfile) do\n      if not emap[f.name] then newFiles[#newFiles+1] = f \n      else \n        if not equalContent(f) and not exclude(f.name) then \n          existingFiles[#existingFiles+1] = f \n        end\n      end\n    end\n    for _,f in ipairs(efile) do \n      if not nmap[f.name] and not exclude(f.name) then \n        deletedFiles[#deletedFiles+1] = f \n      end\n    end\n    \n    local restarted = false\n    for _,f in ipairs(newFiles) do\n      self:log(\"Creating file %s\",f.name)\n      local res,code = api.post(\"\/quickApp\/\"..eid..\"\/files\",f)\n      if code > 201 then ERRORF(\"Failed to create file %s\",f.name) end\n      restarted = true\n    end\n    \n    if next(existingFiles) then\n      for _,f in ipairs(existingFiles) do\n        self:log(\"Updating file %s\",f.name)\n      end\n      local res,code = api.put(\"\/quickApp\/\"..eid..\"\/files\",existingFiles)\n      if code > 202 then ERRORF(\"Failed to update files for QuickApp %d\",eid) end\n      restarted = true\n    end\n    \n    for _,f in ipairs(deletedFiles) do\n      self:log(\"Deleting file %s\",f.name)\n      local _,code = api.delete(\"\/quickApp\/\"..eid..\"\/files\/\"..f.name)\n      if code > 202 then ERRORF(\"Failed to delete file %s\",f.name) end\n      restarted = true\n    end\n    \n    -- Update UI\n    local delay = restarted and 3 or 0\n    local function updateUI()\n      self:log(\"Updating UI\")\n      local viewLayout,uiView,uiCallbacks = nprops.viewLayout,nprops.uiView,nprops.uiCallbacks\n      local _,code = api.put(\"\/devices\/\"..eid,{\n        properties = {\n          viewLayout = viewLayout,\n          uiView = uiView,\n          uiCallbacks = uiCallbacks\n        }\n      })\n      if code > 202 then \n        return ERRORF(\"Failed to update UI for QuickApp %d\",eid)\n      end\n      self:log(\"Update success\")\n    end\n    if delay > 0 then self:log(\"Waiting %ss to update UI...\",delay) end\n    setTimeout(updateUI, 1000*delay) -- Wait for QA to start\n  end)\nend\n\nfunction QuickApp:install()\n  self:getQA(function(ok,res)\n    if not ok then return self:logErr(res) end\n    local fqa = res\n    local res,code = api.post(\"\/quickApp\/\",fqa)\n    if code < 203 then\n      self:updateQAlist()\n      return self:log(\"Install success\")\n    end\n    self:LogErr(\"Install failed %s\",tostring(code))\n  end)\nend\n\nfunction QuickApp:refresh()\n  self:updateDistInfo()\n  self:updateQAlist()\nend\n\nlocal ref = nil\nfunction QuickApp:log(fmt,...)\n  local str = fmt:format(...)\n  self:updateView(\"log\",\"text\",str)\n  self:debug(str)\n  if ref then clearTimeout(ref) end\n  ref = setTimeout(function() self:updateView(\"log\",\"text\",\"\") end,5000)\nend\n\nfunction QuickApp:logErr(fmt,...)\n  local str = fmt:format(...)\n  self:updateView(\"log\",\"text\",\"Err:\"..str)\n  self:error(str)\n  if ref then clearTimeout(ref) end\n  ref = setTimeout(function() self:updateView(\"log\",\"text\",\"\") end,5000)\nend","isMain":true,"type":"lua","name":"main"}]}
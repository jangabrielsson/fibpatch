{"apiVersion":"1.3","initialInterfaces":["quickApp"],"initialProperties":{"apiVersion":"1.3","deviceRole":"Other","useUiView":true,"viewLayout":{"$jason":{"body":{"sections":{"items":[{"components":[{"text":"","name":"title","type":"label","style":{"weight":"1.2"},"visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"text":"QA dist","selectionType":"single","name":"qaSelect","options":{},"values":{},"type":"select","style":{"weight":"1.2"},"visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"text":"Version","selectionType":"single","name":"qaVersion","options":{},"values":{},"type":"select","style":{"weight":"1.2"},"visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"text":"Update","selectionType":"single","name":"qaUpdate","options":{},"values":{},"type":"select","style":{"weight":"1.2"},"visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"text":"","name":"info","type":"label","style":{"weight":"1.2"},"visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"text":"Update","name":"b1","type":"button","style":{"weight":"0.33"},"visible":true},{"text":"Install","name":"b2","type":"button","style":{"weight":"0.33"},"visible":true},{"text":"Refresh","name":"b3","type":"button","style":{"weight":"0.33"},"visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]},"header":{"style":{"height":"300"},"title":"quickApp_device_52"}},"head":{"title":"quickApp_device_52"}}},"typeTemplateInitialized":true,"buildNumber":1,"manufacturer":"","uiCallbacks":[{"eventType":"onToggled","callback":"qaSelect","name":"qaSelect"},{"eventType":"onToggled","callback":"qaVersion","name":"qaVersion"},{"eventType":"onToggled","callback":"qaUpdate","name":"qaUpdate"},{"eventType":"onReleased","callback":"update","name":"b1"},{"eventType":"onLongPressDown","callback":"","name":"b1"},{"eventType":"onLongPressReleased","callback":"","name":"b1"},{"eventType":"onReleased","callback":"install","name":"b2"},{"eventType":"onLongPressDown","callback":"","name":"b2"},{"eventType":"onLongPressReleased","callback":"","name":"b2"},{"eventType":"onReleased","callback":"refresh","name":"b3"},{"eventType":"onLongPressDown","callback":"","name":"b3"},{"eventType":"onLongPressReleased","callback":"","name":"b3"}],"userDescription":"","model":"","useEmbededView":true,"quickAppVariables":[],"uiView":[{"components":[{"text":"","name":"title","type":"label","style":{"weight":"1.0"},"visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"text":"QA dist","options":{},"style":{"weight":"1.0"},"visible":true,"selectionType":"single","type":"select","eventBinding":{"onToggled":[{"type":"deviceAction","params":{"args":["onToggled","qaSelect","$event.value"],"actionName":"UIAction"}}]},"values":{},"name":"qaSelect"}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"text":"Version","options":{},"style":{"weight":"1.0"},"visible":true,"selectionType":"single","type":"select","eventBinding":{"onToggled":[{"type":"deviceAction","params":{"args":["onToggled","qaVersion","$event.value"],"actionName":"UIAction"}}]},"values":{},"name":"qaVersion"}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"text":"Update","options":{},"style":{"weight":"1.0"},"visible":true,"selectionType":"single","type":"select","eventBinding":{"onToggled":[{"type":"deviceAction","params":{"args":["onToggled","qaUpdate","$event.value"],"actionName":"UIAction"}}]},"values":{},"name":"qaUpdate"}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"text":"","name":"info","type":"label","style":{"weight":"1.0"},"visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"text":"Update","eventBinding":{"onReleased":[{"type":"deviceAction","params":{"args":["onReleased","b1"],"actionName":"UIAction"}}],"onLongPressReleased":[{"type":"deviceAction","params":{"args":["onLongPressReleased","b1"],"actionName":"UIAction"}}],"onLongPressDown":[{"type":"deviceAction","params":{"args":["onLongPressDown","b1"],"actionName":"UIAction"}}]},"type":"button","visible":true,"style":{"weight":"0.25"},"name":"b1"},{"text":"Install","eventBinding":{"onReleased":[{"type":"deviceAction","params":{"args":["onReleased","b2"],"actionName":"UIAction"}}],"onLongPressReleased":[{"type":"deviceAction","params":{"args":["onLongPressReleased","b2"],"actionName":"UIAction"}}],"onLongPressDown":[{"type":"deviceAction","params":{"args":["onLongPressDown","b2"],"actionName":"UIAction"}}]},"type":"button","visible":true,"style":{"weight":"0.25"},"name":"b2"},{"text":"Refresh","eventBinding":{"onReleased":[{"type":"deviceAction","params":{"args":["onReleased","b3"],"actionName":"UIAction"}}],"onLongPressReleased":[{"type":"deviceAction","params":{"args":["onLongPressReleased","b3"],"actionName":"UIAction"}}],"onLongPressDown":[{"type":"deviceAction","params":{"args":["onLongPressDown","b3"],"actionName":"UIAction"}}]},"type":"button","visible":true,"style":{"weight":"0.25"},"name":"b3"}],"style":{"weight":"1.0"},"type":"horizontal"}],"supportedDeviceRoles":["Other"],"quickAppUuid":""},"type":"com.fibaro.genericDevice","files":[{"type":"lua","isOpen":false,"content":"local fmt = string.format\n\nlocal EVENT = fibaro.EVENT or {}\nfibaro.EVENT = EVENT\n\nfunction QuickApp:post(event)\n  if EVENT[event.type] then\n    setTimeout(function() EVENT[event.type](event) end,0)\n  end\nend\n\nfunction table.map(t,f)\n  local r = {}\n  for i,v in ipairs(t) do\n    r[i] = f(v)\n  end\n  return r\nend\n\n----------------- Github -----------------\nlocal function urlencode(str) -- very useful\n  if str then\n    str = str:gsub(\"\\n\", \"\\r\\n\")\n    str = str:gsub(\"([ %-%_%.%~])\", function(c)\n      return (\"%%%02X\"):format(string.byte(c))\n    end)\n    str = str:gsub(\" \", \"%%20\")\n  end\n  return str\t\nend\n\nlocal function trim(s)\n  return s:match(\"(.+)%.fqa$\") or s\nend\n\nfunction QuickApp:getLibraryFile(url,cb)\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status < 204 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\nfunction QuickApp:git_getQA(user,repo,name,tag,cb)\n  local url = urlencode(fmt(\"\/%s\/%s\/%s\/%s\",user,repo,tag,name))\n  url = \"https:\/\/raw.githubusercontent.com\"..url\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status == 200 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\nfunction QuickApp:git_getQAReleases(user,repo,name,cb)\n  name = trim(name)\n  name = name..\".releases\"\n  local url = urlencode(fmt(\"\/%s\/%s\/master\/%s\",user,repo,name))\n  url = \"https:\/\/raw.githubusercontent.com\"..url\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status == 200 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\nfunction QuickApp:git_getQATags(user,repo,cb)\n  local url = fmt(\"https:\/\/api.github.com\/repos\/%s\/%s\/tags\",user,repo)\n  net.HTTPClient():request(url,{\n    options = {checkCertificate = false, timeout=20000},\n    success = function(response)\n      if response and response.status == 200 then\n        cb(true,response.data)\n      else cb(false,response and response.status or \"nil\") end\n    end,\n    error = function(err) cb(false,err) end\n  })\nend\n\n------------------ Selectable ------------------\nlocal function mkKey(item) return tostring(item):gsub(\"[^%w]\",\"\") end\nSelectable = Selectable\nclass 'Selectable'\nfunction Selectable:__init(qa,id,fun)\n  self.id = id\n  self.qa = qa\n  self.fun = fun\n  self.qa[fun] = function(_,event)\n    if self.map == nil then\n      return fibaro.warning(__TAG,\"Selectable \"..self.id..\" not initialized\")\n    end\n    self.value = tostring(event.values[1])\n    self.item = self.map[self.value]\n    if self.selected then\n      self:selected(self.item)\n    end\n  end\nend\nfunction Selectable:update(list)\n  local r = {}\n  for _,item in pairs(list) do\n    if self.filter then \n      if self:filter(item) then table.insert(r,item) end\n    else table.insert(r,item) end\n  end\n  if self.sort then\n    local function sort(a,b) return self:sort(a,b) end\n    table.sort(r,sort) \n  end\n  self.list = r\n  self.map = {}\n  local options = {}\n  for _,item in ipairs(self.list) do\n    local key = mkKey(self:key(item)) -- corrected parenthesis\n    local name = self:name(item)\n    self.map[key] = item\n    table.insert(options,{text=name,type='option',value=key})\n  end\n  --print(\"Updated\",self.id,#options)\n  self:_updateList(\"options\",options)\nend\nfunction Selectable:select(key)\n  key = mkKey(key)\n  if not self.map[key] then \n    return fibaro.warning(__TAG,\"Invalid key: \"..key)\n  end\n  self:_updateList(\"selectedItem\",key)\n  self.qa[self.fun](self.qa,{values={key}})\n  self:selected(self.map[key])\nend\n\nfunction Selectable:_updateList(prop,value)\n  self.qa:updateView(self.id,prop,value)\nend\n\n--[[\nfunction Selectable:selected(value) ...end\nfunction Selectable:key(item) return item.key end\nfunction Selectable:name(item) return item.name end\nfunction Selectable:sort(a,b) return a.name < b.name end\nSelectable.value\n--]]","isMain":false,"name":"utils"},{"type":"lua","isOpen":false,"content":"QA_DIR = {\n  {user=\"jangabrielsson\",repo=\"fibpatch\",name=\"QA_A.fqa\"},\n  {user=\"jangabrielsson\",repo=\"fibpatch\",name=\"QA B.fqa\"},\n}\n\nQA_LIBRARIES = {\n  -- \"htp:\/\/host\/path\/lib.json\"\n}","isMain":false,"name":"dir"},{"type":"lua","isOpen":false,"content":"_DEVELOP=\"..\/hc3emu\"\nif require and not QuickApp then require('hc3emu') end\n\n--%%name=fibpatch\n--%%type=com.fibaro.genericDevice\n--%%proxy=FibPatchProxy\n--%%save=FibPatch.fqa\n--%%file=utils.lua:utils\n--%%file=dir.lua:dir\n\n--%%u={label='title',text=''}\n--%%u={select='qaSelect', text='QA dist', onToggled='qaSelect', options={}}\n--%%u={select='qaVersion', text='Version', onToggled='qaVersion', options={}}\n--%%u={select='qaUpdate', text='Update', onToggled='qaUpdate', options={}}\n--%%u={label='info',text=''}\n--%%u={{button='b1', text='Update', onReleased='update'},{button='b2', text='Install', onReleased='install'},{button='b3', text='Refresh', onReleased='refresh'}}\n\nlocal test = fibaro.hc3emu ~= nil\nlocal VERSION = \"0.1.0\"\n\nlocal fmt = string.format\nlocal EVENT = fibaro.EVENT or {}\nfibaro.EVENT = EVENT\nQAs,Versions,Dists = QAs,Versions,Dists\n\nlocal function ERRORF(fmt,...) fibaro.error(__TAG,fmt:format(...)) end\n\nlocal function trim(s)\n  return s:match(\"(.+)%.fqa$\") or s\nend\n\nif test then fibaro.hc3emu.installLocal = true end\n\nlocal QAS = {}\n\nclass \"Dists\"(Selectable)\nfunction Dists:__init(qa) Selectable.__init(self,qa,\"qaSelect\",\"qaSelect\") end\nfunction Dists:name(item) return trim(item.name) end\nfunction Dists:key(item) return item.name end\nfunction Dists:sort(a,b) return a.name < b.name end\nfunction Dists:selected(item)\n  DistUID = item.info.uid\n  self.qa.versions:update(item.info.versions)\n  self.qa.qas:update(QAS)\n  self.qa:updateInfo()\nend\n\nclass \"Versions\"(Selectable)\nfunction Versions:__init(qa) Selectable.__init(self,qa,\"qaVersion\",\"qaVersion\") end\nfunction Versions:name(item) return fmt(\"%s, %s\",item.version,item.description) end\nfunction Versions:key(item) return item.version end\nfunction Versions:sort(a,b) return a.version < b.version end\nfunction Versions:selected(item) self.qa:updateInfo() end\n\nclass \"QAs\"(Selectable)\nfunction QAs:__init(qa) Selectable.__init(self,qa,\"qaUpdate\",\"qaUpdate\") end\nfunction QAs:name(item) return fmt(\"%s: %s\",item.id,item.name) end\nfunction QAs:key(item) return item.id end\nfunction QAs:sort(a,b) return a.name < b.name end\nfunction QAs:filter(item) return item.properties.quickAppUuid == DistUID end\nfunction QAs:selected(item) self.qa:updateInfo() end\n\nfunction QuickApp:onInit()\n  self:debug(self.name,self.id)\n  self:updateView(\"title\",\"text\",fmt(\"FibPatch v%s\",VERSION))\n  if test then \n    fibaro.hc3emu.loadQA(\"test\/QA_A.lua\")\n    fibaro.hc3emu.loadQA(\"test\/QA_B.lua\")\n  end\n  \n  self.dists = Dists(self)\n  self.versions = Versions(self)\n  self.qas = QAs(self)\n  \n  self:updateDistInfo()\n  self:updateQAlist()\n  \n  if test then \n  -- self:testQA(\"install\",\"QA_A.fqa\",\"1.0\",nil,2000)\n    self:testQA(\"install\",\"QA_A.fqa\",\"1.0\",nil,2000)\n  \n    self:testQA(\"update\",\"QA_A.fqa\",\"1.1\",5002,6000)\n  end\nend\n\nfunction QuickApp:testQA(cmd,name,version,id,time) -- for testing in emulator\n  time = time or 4000\n  setTimeout(function() \n    self.dists:select(name)\n    self.versions:select(version)\n    if cmd == \"update\" then \n      self.qas:select(id)\n      self:update()\n    elseif cmd == \"install\" then self:install() end\n  end,time)\nend\n\nlocal dir = {}\nlocal function addDist(dist)\n  local stat,res = pcall(function()\n  local key = dist.user..dist.repo..dist.name\n    dir[key] = dist\n  end)\n  local stat2,res2 = pcall(json.encode,dist)\n  res = stat2 and res2 or res\n  if not stat then ERRORF(\"Error adding dist %s\",tostring(res)) end\nend\n\nfunction QuickApp:updateQADir()\n  local n = 0\n  for _,_ in pairs(dir) do n = n+1 end\n  for k,qa in pairs(dir) do \n    local key,user,repo,name = k,qa.user,qa.repo,qa.name\n    self:git_getQAReleases(user,repo,name,function(ok,data)\n      n = n-1\n      if ok then \n        dir[key].info = json.decode(data)\n        self:debug(fmt(\"Updated %s.%s.%s\",user,repo,name))\n      else self:error(fmt(\"fetching repo %s:%s:%s\", user, repo, name)) end\n      if n == 0 then self.dists:update(dir) end  -- updated to call dists\n    end)\n  end\nend\n\nfunction QuickApp:updateDistInfo()\n  dir = {}\n  for _,dist in ipairs(QA_DIR or {}) do addDist(dist) end\n  local n = #QA_LIBRARIES\n  if n == 0 then return self:updateQADir() end\n  for _,url in ipairs(QA_LIBRARIES or {}) do\n    self:getLibraryFile(url,function(ok,lib)\n      n = n-1\n      if ok then\n        ok,lib = pcall(json.decode,lib)\n        if ok then for _,dist in ipairs(lib) do addDist(dist) end end\n      else self:error(fmt(\"fetching library %s\",url)) end\n      if n == 0 then self:updateQADir() end\n    end)\n  end\nend\n\nlocal qas = {}\nfunction QuickApp:updateQAlist()\n  local res = api.get(\"\/devices?interface=quickApp\") or {}\n  qas = {}\n  for _,d in ipairs(res) do\n    if \n    (d.parentId==nil or d.parentId==0) and\n    (d.encrypted == nil or d.encrypted == false)\n    then\n      table.insert(qas,d)\n    end\n  end\n  QAS = qas\n  self.qas:update(qas)\nend\n\nfunction QuickApp:updateInfo()\n  local str = fmt(\"QA:%s\\nVersion:%s\\nUpdate:%s\"\n  ,self.dists.item and self.dists.item.name or \"N\/A\"\n  ,self.versions.item and self.versions.item.version or \"N\/A\"\n  ,self.qas.item and self.qas.item.name or \"N\/A\"\n)\nlocal updb = self.dists.item and self.versions.item and self.qas.item and true or false\nself:updateView(\"b1\",\"visible\",updb)\nself:updateView(\"info\",\"text\",str)\nend\n\nfunction QuickApp:getQA(cb)\n  if not(self.dists.item and self.versions.item) then\n    return self:error(\"Please select dist, version to install\")\n  end\n  local dist = self.dists.item\n  local version = self.versions.item\n  local tag = version.tag\n  if not tag then \n    return self:error(fmt(\"Version %s not found\",version.version))\n  end\n  self:git_getQA(dist.user,dist.repo,dist.name,tag,function(ok,res)\n    if ok then ok,res = pcall(json.decode,res) end\n    cb(ok,res)\n  end)\nend\n\nfunction QuickApp:update()\n  self:debug(\"Update\")\n  if not self.qas.item then\n    return self:error(\"Please select QA to update\")\n  end\n  self:getQA(function(ok,res)\n    if not ok then return self:error(res) end\n    local eid = self.qas.item.id\n    local version = self.versions.item\n\n    local function exclude(name)\n      for _,p in ipairs(version.exclude or {}) do\n        local pp = p:match(\"^p:(.*)$\")\n        if pp then return name:match(pp) else return name == p end\n      end \n    end\n\n    local function equalContent(f)\n      local res,code = api.get(fmt(\"\/quickApp\/%s\/files\/%s\",eid,f.name))\n      if code > 202 then return false end\n      return res.content == f.content\n    end\n\n    local fqa = res\n    \n    local nprops = fqa.initialProperties\n    local nifs = fqa.initialInterfaces -- do this in QA...\n    \n    -- update files\n    local efile = api.get(fmt(\"\/quickApp\/%s\/files\",eid))\n    local nfile = fqa.files\n    local emap,nmap = {},{}\n    local newFiles = {}\n    local existingFiles = {}\n    local deletedFiles = {}\n    \n    for _,f in ipairs(nfile) do nmap[f.name] = f end\n    for _,f in ipairs(efile) do emap[f.name] = f end\n    for _,f in ipairs(nfile) do\n      if not emap[f.name] then newFiles[#newFiles+1] = f \n      else \n        if not equalContent(f) and not exclude(f.name) then \n          existingFiles[#existingFiles+1] = f \n        end\n      end\n    end\n    for _,f in ipairs(efile) do \n      if not nmap[f.name] and not exclude(f.name) then \n        deletedFiles[#deletedFiles+1] = f \n      end\n    end\n    \n    local restarted = false\n    for _,f in ipairs(newFiles) do\n      self:log(\"Creating file %s\",f.name)\n      local res,code = api.post(\"\/quickApp\/\"..eid..\"\/files\",f)\n      if code > 201 then ERRORF(\"Failed to create file %s\",f.name) end\n      restarted = true\n    end\n    \n    if next(existingFiles) then\n      for _,f in ipairs(existingFiles) do\n        self:log(\"Updating file %s\",f.name)\n      end\n      local res,code = api.put(\"\/quickApp\/\"..eid..\"\/files\",existingFiles)\n      if code > 202 then ERRORF(\"Failed to update files for QuickApp %d\",eid) end\n      restarted = true\n    end\n    \n    for _,f in ipairs(deletedFiles) do\n      self:log(\"Deleting file %s\",f.name)\n      local _,code = api.delete(\"\/quickApp\/\"..eid..\"\/files\/\"..f.name)\n      if code > 202 then ERRORF(\"Failed to delete file %s\",f.name) end\n      restarted = true\n    end\n    \n    -- Update UI\n    local delay = restarted and 3 or 0\n    local function updateUI()\n      self:log(\"Updating UI\")\n      local viewLayout,uiView,uiCallbacks = nprops.viewLayout,nprops.uiView,nprops.uiCallbacks\n      local _,code = api.put(\"\/devices\/\"..eid,{\n        properties = {\n          viewLayout = viewLayout,\n          uiView = uiView,\n          uiCallbacks = uiCallbacks\n        }\n      })\n      if code > 202 then \n        return ERRORF(\"Failed to update UI for QuickApp %d\",eid)\n      end\n      self:log(\"Update success\")\n    end\n    if delay > 0 then self:log(\"Waiting %ss to update UI...\",delay) end\n    setTimeout(updateUI, 1000*delay) -- Wait for QA to start\n  end)\nend\n\nfunction QuickApp:install()\n  self:getQA(function(ok,res)\n    if not ok then return self:error(res) end\n    local fqa = res\n    local res,code = api.post(\"\/quickApp\/\",fqa)\n    if code < 203 then\n      self:updateQAlist()\n      return self:log(\"Install success\")\n    end\n    self:error(\"Install failed\",code)\n  end)\nend\n\nfunction QuickApp:refresh()\n  self:updateDistInfo()\n  self:updateQAlist()\nend\n\nfunction QuickApp:log(fmt,...)\n  self:debug(fmt:format(...))\nend","isMain":true,"name":"main"}],"name":"FibPatchProxy"}